(FOR GUI)
1. You need to have the graphics package installed on your system through opam.

Run "opam install graphics" in the terminal and you should be good to go. 

2. To actually run the GUI, and what we have so far, you can type in the 
command "make graph" into the terminal once in base directory for this project. 

3. Features: 
    |> Once you run make graph, you will see a window pop up, we have 
    automatically designed it to make it a 1000x1000 window. You should not 
    see anything when you first open it. If you click the window and then 
    press and hold any key, you should see a sine curve appear and move 
    leftwards. 

    |> There are also many things that we made adjustable. The variables sx and
    sy define the scaling of the values of x and y. For example if sx=10 then 
    10 pixels will equal 1 on the x axis. You can also change the size of the 
    window by running open_graph " {dimensions here}" (notice the space at the
    beginning). 

    |> In terms of features we can change from our end, we can graph basically 
    any 2d function, we can change the speed at which the graph evolves, 
    and we can change the input that makes it evolve. For example in this
    sprint we made it so that you can press a key to make the graph 
    shift left, but we could also do something like make the graph shift upwards
    based on the certain position of your mouse. 

4. Error handling: 

(a) If you run into an error that says its missing some system dependencies when 
you try and install the graphics module, it will list out those system 
dependencies and you can run "brew install {insert system dependency here}" 
and try again. 

(b) If you run into the error "exception Graphics.Graphic_failure('Cannot'
open display {insert display name here}')" the only fix we have found around 
this so far is that you need to explicitely tell the graphics module exactly
which window to open. If you go to our file you will see a command to the 
function "open_graph" provided by the graphics module. What we have in there 
to begin with is open_graph " 1000x1000" which opens a window with those 
dimensions. To fix the detection problem, you need to type: open_graph 
" {insert display name here}". Once you do that and it actually recognizes 
the display you can revert back to the old open_graph command to 
open_graph " 1000x1000" and it should give you our graph as intended. 

(FOR EVOLUTION)
No additional depends should be required.

The way the code is structured is that you pick a solver by choosing one of the three modules of signature 1DEvolution. In order to solve the Schrodinger equation, you must feed the code an "initial condition", which should be a list of Complex.t values representing the amplitudes of the wave function at each gridpoint in the discretized domain. The length of this array is the number of gridpoints, which is inversely proportional to the error of the method, as the distance between gridpoints is equal to the length of the domain divided by the number of gridpoints. Read https://en.wikipedia.org/wiki/Finite_difference_method for more information regarding the math. After picking an initial condition represented by a Complex.t list init_condition (note: this list should have at least four elements, as otherwise the finite difference method does not properly work), as well as a domain d and a boundary condition b, according to the types specified in the file, you can solve the Schrodinger equation as such:

1. Apply from_list to init_condition to get the representation type of your initial condition.
2. Apply evolve to the init_condition to get the representation type of the final wave function, after some period of time. Arg w is the representation type of the initial condition, returned by (1.). The argument tau is the step-size in time of the approximation (Note: for either of the modules containing Eulers in the name, this step size MUST be on the order of 10^-3 to be numerically stable.) The argument b is the chosen boundary condition (look at the type defined at the top of the file for valid arguments). The argument d is the domain, represented by two floats, the left endpoint, and the right endpoint. For the Harmonic Oscillator, these endpoints must be equal and opposite (i.e. (-1.0, 1.0)). The argument time is the total time to evolve the wave function, as in the time after which you want to know the wave function. The argument print says whether to print the value of the wavefunction at each time step, but this has not been implemented yet, so you can always pass false to it if you like. 
3. Apply probabilities to the value returned by (2.) to get a list of the probability densities at the final time, or to_list to get a Complex.t list representation of the wave function at the final time.
